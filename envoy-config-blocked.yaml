apiVersion: v1
kind: ConfigMap
metadata:
  name: envoy-config
  namespace: demo
data:
  envoy.yaml: |
    static_resources:
      listeners:
      - name: listener_0
        address:
          socket_address:
            address: 0.0.0.0
            port_value: 10000
        filter_chains:
        - filters:
          - name: envoy.filters.network.http_connection_manager
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
              stat_prefix: ingress_http
              access_log:
              - name: envoy.access_loggers.stdout
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog
              http_filters:
              - name: envoy.filters.http.jwt_authn
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
                  providers:
                    local_provider:
                      local_jwks:
                        inline_string: |
                          {
                            "keys": [{
                              "kty": "oct",
                              "alg": "HS256",
                              "k": "aWFtX2F1dGhfc2VjcmV0"
                            }]
                          }
                      from_headers:
                      - name: Authorization
                        value_prefix: "Bearer "
                      forward: true
                      payload_in_metadata: jwt_payload
                      clock_skew_seconds: 60
                  rules:
                  - match:
                      prefix: "/"
                    requires:
                      provider_name: "local_provider"
              - name: envoy.filters.http.lua
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
                  default_source_code:
                    inline_string: |
                      -- Load blocklist from CSV files
                      local blocked_users = {}
                      local blocked_devices = {}
                      local whitelisted_paths = {}
                      
                      -- Function to load CSV
                      function load_csv(filename, table)
                        local file = io.open(filename, "r")
                        if file then
                          local header = true
                          for line in file:lines() do
                            if header then
                              header = false
                            else
                              local value = line:match("^%s*(.-)%s*$")
                              if value and value ~= "" then
                                table[value] = true
                              end
                            end
                          end
                          file:close()
                          return true
                        end
                        return false
                      end

                      function load_whitelist()
                        local file = io.open("/whitelist/list.txt", "r")
                        if file then
                          for line in file:lines() do
                            -- Skip empty lines and comments
                            local path = line:match("^%s*([^#]*)%s*$")
                            if path and path ~= "" then
                              whitelisted_paths[path] = true
                              print("LUA: Whitelisted path: " .. path)
                            end
                          end
                          file:close()
                          print("LUA: Whitelist loaded successfully")
                        else
                          print("LUA: Warning - Could not load whitelist file")
                        end
                      end
                      
                      -- Load blocklists on startup
                      load_csv("/blocklist/blocked_users.csv", blocked_users)
                      load_csv("/blocklist/blocked_devices.csv", blocked_devices)
                      load_whitelist()
                      
                      function envoy_on_request(request_handle)
                        local start_time = os.clock()
                        request_handle:logInfo("LUA: Processing request")

                        local path = request_handle:headers():get(":path")
                        
                        -- Check if path is whitelisted
                        if path and whitelisted_paths[path] then
                          print("LUA: Path " .. path .. " is whitelisted, skipping JWT")
                          -- Add a header to indicate JWT should be skipped
                          request_handle:headers():add("x-skip-jwt", "true")
                        end
                        
                        -- Get JWT metadata
                        local meta = request_handle:streamInfo():dynamicMetadata()
                        local jwt_data = meta:get("envoy.filters.http.jwt_authn")
                        
                        if jwt_data and jwt_data["jwt_payload"] then
                          local payload = jwt_data["jwt_payload"]
                          
                          -- Check custom expiry
                          local current_time = os.time()
                          local expiry = payload["expiry"]
                          if expiry and tonumber(expiry) < current_time then
                            local elapsed_ms = (os.clock() - start_time) * 1000
                            request_handle:logInfo(string.format("LUA: Token expired check took %.3f ms", elapsed_ms))
                            request_handle:respond(
                              {[":status"] = "403", ["content-type"] = "application/json"},
                              '{"code": "TOKEN_EXPIRED", "message": "Access token expired, please refresh"}'
                            )
                            return
                          end
                          
                          -- Extract values
                          local uid = payload["uid"]
                          local device_id = payload["device_id"]
                          
                          -- Check if user is blocked
                          if uid and blocked_users[tostring(uid)] then
                            local elapsed_ms = (os.clock() - start_time) * 1000
                            request_handle:logInfo(string.format("LUA: User blocked check took %.3f ms", elapsed_ms))
                            request_handle:respond(
                              {[":status"] = "401", ["content-type"] = "application/json"},
                              '{"code": "USER_BLOCKED", "message": "User is blocked"}'
                            )
                            return
                          end
                          
                          -- Check if device is blocked
                          if device_id and blocked_devices[tostring(device_id)] then
                            local elapsed_ms = (os.clock() - start_time) * 1000
                            request_handle:logInfo(string.format("LUA: Device blocked check took %.3f ms", elapsed_ms))
                            request_handle:respond(
                              {[":status"] = "401", ["content-type"] = "application/json"},
                              '{"code": "DEVICE_BLOCKED", "message": "Device is blocked"}'
                            )
                            return
                          end
                          
                          -- Add headers
                          if uid then
                            request_handle:headers():add("x-auth-uid", tostring(uid))
                          end
                          if device_id then
                            request_handle:headers():add("x-auth-deviceid", tostring(device_id))
                          end
                          
                          -- Remove original headers
                          request_handle:headers():remove("uid")
                          request_handle:headers():remove("device_id")
                          
                          local elapsed_ms = (os.clock() - start_time) * 1000
                          request_handle:logInfo(string.format("LUA: Request processing took %.3f ms", elapsed_ms))
                        end
                      end
                      
                      function envoy_on_response(response_handle)
                        local status = response_handle:headers():get(":status")
                        if status == "401" then
                          local www_auth = response_handle:headers():get("www-authenticate")
                          if www_auth and string.find(www_auth, "Bearer") then
                            response_handle:headers():replace(":status", "401")
                            response_handle:headers():replace("content-type", "application/json")
                            response_handle:headers():remove("www-authenticate")
                            response_handle:body():setBytes('{"code": "UNAUTHORIZED", "message": "Invalid token"}')
                          end
                        end
                      end
              - name: envoy.filters.http.router
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
              route_config:
                name: local_route
                virtual_hosts:
                - name: local_service
                  domains: ["*"]
                  routes:
                  - match:
                      prefix: "/"
                    route:
                      cluster: api_service
      clusters:
      - name: api_service
        connect_timeout: 5s
        type: LOGICAL_DNS
        lb_policy: ROUND_ROBIN
        load_assignment:
          cluster_name: api_service
          endpoints:
          - lb_endpoints:
            - endpoint:
                address:
                  socket_address:
                    address: api-server.demo.svc.cluster.local
                    port_value: 80